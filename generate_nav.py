#!/usr/bin/env python3

import re
import sys
from pathlib import Path

# --- Configuration ---
CWD = Path.cwd()
SRC_DIR = CWD / "src"
MODULE_ROOT = SRC_DIR / "modules/ROOT"
PAGES_DIR = MODULE_ROOT / "pages"
PARTIALS_DIR = MODULE_ROOT / "partials"
DEST_NAV_FILE = MODULE_ROOT / "nav.adoc"

MASTER_FILES = [
    "usersguide/usersguide.adoc",
    "installguide/installguide.adoc",
    "referenceguide/referenceguide.adoc",
]

def get_adoc_title(adoc_path: Path) -> str:
    """Reads an AsciiDoc file and returns the text of its main title (= Title)."""
    if not adoc_path.exists():
        print(f"  -> WARNING: File not found for title scan: {adoc_path}", file=sys.stderr)
        return "File Not Found"
    try:
        for line in adoc_path.read_text(encoding='utf-8').splitlines():
            if line.startswith('= '):
                return line.lstrip('= ').strip()
        return "Untitled"
    except Exception as e:
        print(f"  -> WARNING: Could not read {adoc_path}. Error: {e}", file=sys.stderr)
        return "Parse Error"

def process_adoc_file_recursively(file_path: Path, current_level: int) -> list[str]:
    """
    Reads an AsciiDoc file, finds its headings, and generates nav entries.
    This function does NOT handle includes, only headings within a single file.
    """
    if not file_path.exists():
        return []
        
    content = file_path.read_text(encoding='utf-8')
    nav_lines = []
    
    # Regex to find headings (==, ===, etc.) and their IDs ([[...]])
    heading_regex = re.compile(r'^(?:\[\[([^\]]+)\]\]\s*)?(=+)\s+(.*)$', re.MULTILINE)
    
    for match in heading_regex.finditer(content):
        anchor, equals, title = match.groups()
        level = len(equals)
        
        # We only want headings from level 2 downwards for the nav tree
        if level < 2:
            continue
            
        indent = "*" * (current_level + level - 1)
        
        # Create an xref to the anchor ID within the file
        xref_path = file_path.relative_to(PAGES_DIR)
        nav_lines.append(f"{indent} xref:{xref_path}#{anchor}[{title}]")
        
    return nav_lines

def main():
    """Generates a deep, recursive nav.adoc by parsing master files and their includes."""
    header = [
        "//",
        "// WARNING: This file is generated by scripts/generate_nav.py.",
        "// DO NOT EDIT THIS FILE DIRECTLY.",
        "//",
    ]
    print("=== Generating deep navigation from AsciiDoc source ===")
    nav_lines = []

    for master_file_rel_path in MASTER_FILES:
        master_path = PAGES_DIR / master_file_rel_path
        if not master_path.exists():
            continue

        book_title = get_adoc_title(master_path)
        nav_lines.append(f"* {book_title}")

        content = master_path.read_text(encoding='utf-8')
        include_matches = re.findall(r'^include::([^\[]+)\[\]', content, re.MULTILINE)

        for include_rel_path in include_matches:
            chapter_path = (master_path.parent / include_rel_path).resolve()
            if PARTIALS_DIR in chapter_path.parents:
                continue

            chapter_title = get_adoc_title(chapter_path)
            xref_path = chapter_path.relative_to(PAGES_DIR)
            
            # Add the main chapter link at level 2
            nav_lines.append(f"** xref:{xref_path}[{chapter_title}]")
            
            # Now, recursively process the *headings inside* that chapter file
            # The sub-headings will start at level 3 (***)
            sub_nav_lines = process_adoc_file_recursively(chapter_path, current_level=2)
            nav_lines.extend(sub_nav_lines)

    final_content = "\n".join(header + nav_lines) + "\n"
    DEST_NAV_FILE.write_text(final_content, encoding='utf-8')
    print(f"  -> Successfully generated deep navigation in {DEST_NAV_FILE}")

if __name__ == "__main__":
    main()
